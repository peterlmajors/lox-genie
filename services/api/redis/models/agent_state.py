"""
Redis models for AgentState - API service version
"""
from datetime import datetime
from pydantic import BaseModel, Field
from typing import List, Any, Dict, Union, Optional
import uuid
from langchain_core.messages import HumanMessage, AIMessage


# Response schemas
class GatekeeperResponse(BaseModel):
    action: str = Field(..., description="The action to take: direct_answer, research_required, clarification_needed, or off_topic")
    response: str = Field(default="", description="The response to give to the user")


class PlanResponse(BaseModel):
    plan_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique ID for the plan.")
    subtasks: List[str] = Field(..., description="List of subtasks to perform.")


class ToolExecutorResponse(BaseModel):
    tool_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique ID for the tool execution.")
    plan_id: str = Field(..., description="Unique ID for the plan.")
    tool: str = Field(..., description="Name of the tool selected to execute the task.")
    parameters: Dict[str, Any] = Field(..., description="Parameters for the tool selected to execute the task.")
    tool_response: Any = Field(..., description="Response from the tool selected to execute the task.")


class MessageCounts(BaseModel):
    message_count: int = Field(0, description="Total number of messages in thread.")
    human_messages: int = Field(0, description="Number of human messages in thread.")
    ai_messages: int = Field(0, description="Number of AI messages in thread.")


class Context(BaseModel):
    context: str = Field(default="", description="Reduced context of the thread.")


# State schemas
class AgentState(BaseModel):
    thread_id: str = Field(default_factory=lambda: str(uuid.uuid4()), description="Unique ID for the agent state.")
    messages: List[Union[HumanMessage, AIMessage]] = Field(default_factory=list, description="Chronological list of chat messages.")
    message_counts: MessageCounts = Field(default=MessageCounts(), description="Number of human and AI messages in thread.")
    reduced_context: Context = Field(default=Context(), description="Reduced context from the thread (moderate-term agent memory).")
    relevant: bool = Field(default=False, description="Whether the latest user message is relevant to the agent's context.")
    plan: List[PlanResponse] = Field(default_factory=list, description="Current plan generated by the agent.")
    tool_calls: List[ToolExecutorResponse] = Field(default_factory=list, description="List tool executions performed.")


class MessageRedis(BaseModel):
    """Redis-compatible message model for serialization"""
    message_type: str = Field(..., description="Type of message: 'human' or 'ai'")
    content: str = Field(..., description="Message content")
    timestamp: datetime = Field(default_factory=datetime.utcnow, description="Message timestamp")
    metadata: Dict[str, Any] = Field(default_factory=dict, description="Additional message metadata")
    
    @classmethod
    def from_langchain_message(cls, message: Union[HumanMessage, AIMessage]) -> 'MessageRedis':
        """Convert LangChain message to Redis message"""
        message_type = "human" if isinstance(message, HumanMessage) else "ai"
        return cls(
            message_type=message_type,
            content=message.content,
            metadata=message.additional_kwargs
        )
    
    def to_langchain_message(self) -> Union[HumanMessage, AIMessage]:
        """Convert Redis message to LangChain message"""
        if self.message_type == "human":
            return HumanMessage(content=self.content, additional_kwargs=self.metadata)
        else:
            return AIMessage(content=self.content, additional_kwargs=self.metadata)


class AgentStateRedis(AgentState):
    """Extended AgentState with Redis-specific functionality"""
    
    # Redis-specific fields
    created_at: datetime = Field(default_factory=datetime.utcnow, description="When this state was created")
    last_updated: datetime = Field(default_factory=datetime.utcnow, description="When this state was last updated")
    ttl_seconds: Optional[int] = Field(default=None, description="Time to live in seconds")
    
    # Override messages to use Redis-compatible format
    messages: List[MessageRedis] = Field(default_factory=list, description="Chronological list of chat messages.")
    
    def update_timestamp(self) -> None:
        """Update the last_updated timestamp"""
        self.last_updated = datetime.utcnow()
    
    def add_langchain_message(self, message: Union[HumanMessage, AIMessage]) -> None:
        """Add a LangChain message to the thread"""
        redis_message = MessageRedis.from_langchain_message(message)
        self.messages.append(redis_message)
        
        # Update message counts
        self.message_counts.message_count += 1
        if isinstance(message, HumanMessage):
            self.message_counts.human_messages += 1
        elif isinstance(message, AIMessage):
            self.message_counts.ai_messages += 1
        
        self.update_timestamp()
    
    def add_message(self, message_type: str, content: str, metadata: Optional[Dict[str, Any]] = None) -> None:
        """Add a new message to the thread"""
        message = MessageRedis(
            message_type=message_type,
            content=content,
            metadata=metadata or {}
        )
        self.messages.append(message)
        
        # Update message counts
        self.message_counts.message_count += 1
        if message_type == "human":
            self.message_counts.human_messages += 1
        elif message_type == "ai":
            self.message_counts.ai_messages += 1
        
        self.update_timestamp()
    
    def add_plan(self, subtasks: List[str]) -> PlanResponse:
        """Add a new plan to the agent state"""
        plan = PlanResponse(subtasks=subtasks)
        self.plan.append(plan)
        self.update_timestamp()
        return plan
    
    def add_tool_call(self, plan_id: str, tool: str, parameters: Dict[str, Any], tool_response: Any) -> ToolExecutorResponse:
        """Add a new tool call to the agent state"""
        tool_call = ToolExecutorResponse(
            plan_id=plan_id,
            tool=tool,
            parameters=parameters,
            tool_response=tool_response
        )
        self.tool_calls.append(tool_call)
        self.update_timestamp()
        return tool_call
    
    def update_context(self, context: str) -> None:
        """Update the reduced context"""
        self.reduced_context.context = context
        self.update_timestamp()
    
    def set_relevance(self, relevant: bool) -> None:
        """Set the relevance flag"""
        self.relevant = relevant
        self.update_timestamp()
    
    def get_langchain_messages(self) -> List[Union[HumanMessage, AIMessage]]:
        """Get messages as LangChain message objects"""
        return [msg.to_langchain_message() for msg in self.messages]
    
    def to_dict(self) -> Dict[str, Any]:
        """Convert to dictionary for Redis storage"""
        return self.model_dump(mode='json')
    
    @classmethod
    def from_dict(cls, data: Dict[str, Any]) -> 'AgentStateRedis':
        """Create from dictionary (Redis retrieval)"""
        return cls(**data)
    
    def get_redis_key(self) -> str:
        """Get the Redis key for this agent state"""
        return f"thread:{self.thread_id}"
    
    @classmethod
    def from_agent_state(cls, agent_state: AgentState) -> 'AgentStateRedis':
        """Convert AgentState to AgentStateRedis"""
        # Convert LangChain messages to Redis messages
        redis_messages = []
        for message in agent_state.messages:
            redis_messages.append(MessageRedis.from_langchain_message(message))
        
        return cls(
            thread_id=agent_state.thread_id,
            messages=redis_messages,
            message_counts=agent_state.message_counts,
            reduced_context=agent_state.reduced_context,
            relevant=agent_state.relevant,
            plan=agent_state.plan,
            tool_calls=agent_state.tool_calls
        )
    
    def to_agent_state(self) -> AgentState:
        """Convert AgentStateRedis to AgentState"""
        # Convert Redis messages to LangChain messages
        langchain_messages = self.get_langchain_messages()
        
        return AgentState(
            thread_id=self.thread_id,
            messages=langchain_messages,
            message_counts=self.message_counts,
            reduced_context=self.reduced_context,
            relevant=self.relevant,
            plan=self.plan,
            tool_calls=self.tool_calls
        )
